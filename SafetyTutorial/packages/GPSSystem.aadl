package GPSSystem
public
	with GPSParts, HardwareParts, EMV2;
	
--	-- initially we focus on service failure
--	-- 	This is reflected in only expressing ServiceOmission as propagation.
--	system GPS_Failure
--	features
--		location: out data port;
--	annex EMV2 {**
--		use types ErrorLibrary, GPSErrorLibrary;
--		error propagations
--		location: out propagation {ServiceOmission};
--		flows
--			GPSes: error source location{ServiceOmission};
--		end propagations;
--		properties
--			-- here we express a requirement that GPS should not fail to provide service more than the specified probability
--			-- This should be met by the FTA based probability analysis.
--			emv2::OccurrenceDistribution => [ ProbabilityValue => 1.5e-5 ; Distribution => Poisson;] applies to GPSes.ServiceOmission;
--	**};
--	end GPS_Failure;
	
	system GPS
	features
		location: out data port;
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		error propagations
		location: out propagation {ObservableErrorTypes};
		flows
			GPSes: error source location{ObservableErrorTypes};
		end propagations;
		properties
			-- here we express a requirement that GPS should not fail to provide service more than the specified probability
			-- This should be met by the FTA based probability analysis.
			emv2::OccurrenceDistribution => [ ProbabilityValue => 1.5e-7 ; Distribution => Poisson;] applies to GPSes.ServiceOmission;
--        -- initial focus is on service failure
--			-- here we express a requirement that GPS should only operate in low precision accordin gto the specified probability
--			-- This should be met by the FTA based probability analysis.
--			emv2::OccurrenceDistribution => [ ProbabilityValue => 2.0e-4 ; Distribution => Poisson;] applies to GPSes.LowPrecisionData;
	**};
	end GPS;
	
	-- this is an early parts model without any connectivity between parts
	-- this is expressed in the composite state logic.
	-- Single sensor as physical system does not give us the reliability, thus, two sensor configuration
	system implementation GPS.parts_SingleSensor
		subcomponents
			sensor1: device GPSParts::sensor;
			cpu: processor HardwareParts::CPU_errorbehavior;
			network: bus HardwareParts::Network;
			powersupply1: device HardwareParts::PowerSupply;
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		use behavior GPSErrorLibrary::FailStopState;
		-- the logic includes knowledge of dual redundenacy of sensors
		-- the logic is the fault tree equivalent of a RBD
		-- when we add occursence probabilities we can calculate the failure rate of GPS
		composite error behavior
		states
		[sensor1.FailStop or cpu.Failstop or network.FailStop or powersupply1.FailStop]-> FailStop;
		end composite;
	**};
	end GPS.parts_SingleSensor;
	
	system implementation GPS.SingleSensorTransient extends GPS.parts_SingleSensor
		subcomponents
			sensor1: refined to device GPSParts::sensor_errorbehavior;
	end GPS.SingleSensorTransient;

	-- system engineers consider option of two sensors to increase GPS reliability.
	system implementation GPS.parts_TwoSensor
		subcomponents
			sensor1: device GPSParts::sensor_errorbehavior;
			sensor2: device GPSParts::sensor_errorbehavior;
			cpu: processor HardwareParts::CPU_errorbehavior;
			network: bus HardwareParts::Network;
			powersupply1: device HardwareParts::PowerSupply;
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		use behavior GPSErrorLibrary::FailStopState;
		-- the logic includes knowledge of dual redundenacy of sensors
		-- the logic is the fault tree equivalent of a RBD
		-- when we add occursence probabilities we can calculate the failure rate of GPS
		composite error behavior
		states
		[sensor1.FailStop and sensor2.FailStop or cpu.Failstop or network.FailStop or powersupply1.FailStop]-> FailStop;
		end composite;
	**};
	end GPS.parts_TwoSensor;

	-- here we are interested in supporting inductive fault impact analysis from a single failure point
	-- and deductive fault contributor analysis (FTA) of a critical effects 
	-- These analyses utilize propagation paths between components and error flows or component error behavior of components.
	-- Starting points for fault impact analysis are error source declarations (or the equivalent in the component erro behavior specification
	-- i.e., error events mapped into out propagations or transitioning error states, which in turn map into out propagations.
	-- Starting point for fault contributor analysis is an error state of the GPS, or an outgoing error propagation.
	-- Note that the redundancy logic is known to the processing unit as it decides what to do when sensor errors are propagated in.
	-- In this configuration the processing software is assumed to have Zero defect, a common assumption made in reliability analysis.
	system implementation GPS.basic
		subcomponents
			sensor1: device GPSParts::sensor_errorbehavior;
			sensor2: device GPSParts::sensor_errorbehavior;
			processing: abstract GPSParts::GPSProcessing_errorbehavior;
			cpu1: processor HardwareParts::CPU_errorbehavior;
			network: bus HardwareParts::Network;
			powersupply1: device HardwareParts::PowerSupply;
		connections
			-- logical connections
			s1toproc: port sensor1.sensedData -> processing.inSensor1;
			s2toproc: port sensor2.sensedData -> processing.inSensor2;
			proctoext: port processing.location -> location;
			-- physical network connections
			s1tonetwork: bus access sensor1.networkaccess <-> network;
			s2tonetwork: bus access sensor2.networkaccess <-> network;
			cputonetwork: bus access cpu1.networkaccess <-> network;
			-- power connections
			powertos1: feature powersupply1.power -> sensor1.powersource ;
			powertos2: feature powersupply1.power -> sensor2.powersource ;
			powertocpu: feature powersupply1.power -> cpu1.powersource ;
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		use behavior GPSErrorLibrary::FailStopState;
		component error behavior
		-- mapping of GPS producing GPS output to the GPS out propagation
		-- since it is a subcomponent single port connected to the GPS port, we could infer the mapping 
		propagations
		FTAStart1: all-[processing.location{ServiceOmission}]-> location;
		end component;
		composite error behavior
		states
		FTAStart2: [processing.FailStop]-> FailStop;
		end composite;
	**};
	end GPS.basic;
	
	-- In this configuration we include software errors as compute errors that result in
	system implementation GPS.computeerror extends GPS.basic
		subcomponents
			processing: refined to abstract GPSParts::GPSProcessing_computeError;
		annex EMV2 {**
		component error behavior
		-- mapping of GPS producing GPS output to the GPS out propagation
		-- since it is a subcomponent single port connected to the GPS port, we could infer the mapping 
		propagations
		FTAComputeErrorStart1: all-[processing.location{LowPrecisionData}]-> location{LowPrecisionData};
		end component;
		composite error behavior
		states
		FTAComputeErrorStart2: [processing.Failed{ServiceOmission}]-> FailStop;
		end composite;
		**};
	end GPS.computeerror;
	
	system implementation GPS.BasicBound extends GPS.basic
		properties
			Actual_Processor_Binding => (reference (cpu1)) applies to processing;
			Actual_Connection_Binding => (reference (network)) applies to s1toproc;
			Actual_Connection_Binding => (reference (network)) applies to s2toproc;
--			Actual_Connection_Binding => (reference (network)) applies to proctoext;
	end GPS.BasicBound;
	
	system implementation GPS.CEBound extends GPS.computeerror
		properties
			Actual_Processor_Binding => (reference (cpu1)) applies to processing;
			Actual_Connection_Binding => (reference (network)) applies to s1toproc;
			Actual_Connection_Binding => (reference (network)) applies to s2toproc;
--			Actual_Connection_Binding => (reference (network)) applies to proctoext;
	end GPS.CEBound;
	
	system implementation GPS.Dual 
		subcomponents
			sensor1: device GPSParts::sensor_errorbehavior;
			sensor2: device GPSParts::sensor_errorbehavior;
			processing1: abstract GPSParts::GPSProcessing_errorbehavior;
			processing2: abstract GPSParts::GPSProcessing_errorbehavior;
			voter: abstract GPSParts::GPSVoter;
			cpu1: processor HardwareParts::CPU_errorbehavior;
			network: bus HardwareParts::Network;
			powersupply1: device HardwareParts::PowerSupply;
			cpu2: processor HardwareParts::CPU_errorbehavior;
		connections
			-- logical connections
			s1toproc2: port sensor1.sensedData -> processing2.inSensor1;
			s2toproc2: port sensor2.sensedData -> processing2.inSensor2;
			proc2tovoter: port processing2.location -> voter.in1;
			s1toproc: port sensor1.sensedData -> processing1.inSensor1;
			s2toproc: port sensor2.sensedData -> processing1.inSensor2;
			proc1tovoter: port processing1.location -> voter.in2;
			votertoext: port voter.outp -> location;
			-- physical network connections
			s1tonetwork: bus access sensor1.networkaccess <-> network;
			s2tonetwork: bus access sensor2.networkaccess <-> network;
			cpu1tonetwork: bus access cpu1.networkaccess <-> network;
			cpu2tonetwork: bus access cpu2.networkaccess <-> network;
			-- power connections
			powertos1: feature powersupply1.power -> sensor1.powersource ;
			powertos2: feature powersupply1.power -> sensor2.powersource ;
			powertocpu: feature powersupply1.power -> cpu1.powersource ;
		properties
			-- note that the voter is on the same processor as one of the processing units.
			-- The failure of CPU1 will take out the GPS. Thus, limited value in replicating CPUs and processing.
			Actual_Processor_Binding => (reference (cpu1)) applies to processing1;
			Actual_Processor_Binding => (reference (cpu2)) applies to processing2;
			Actual_Processor_Binding => (reference (cpu1)) applies to voter;
			Actual_Connection_Binding => (reference (network)) applies to s1toproc;
			Actual_Connection_Binding => (reference (network)) applies to s2toproc;
			Actual_Connection_Binding => (reference (network)) applies to proc1tovoter;
			Actual_Connection_Binding => (reference (network)) applies to proc2tovoter;
		annex EMV2 {**
			use types ErrorLibrary, GPSErrorLibrary;
			use behavior GPSErrorLibrary::FailStopState;
		error propagations
		location: out propagation {ServiceOmission,LowPrecisionData};
		flows
			GPSes: error source location{ServiceOmission,LowPrecisionData};
		end propagations;
		component error behavior
		propagations
			FTAPropagationStart: all -[processing1.location{ServiceOmission}]-> location{ServiceOmission};
		end component;
			composite error behavior
			states
				FTAStateStart: [processing1.FailStop and processing2.Failstop]-> FailStop;
			end composite;
		**};
	end GPS.Dual;

end GPSSystem;
