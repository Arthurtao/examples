package GPSParts
public
	with emv2;
		
Device sensor
features
	sensedData: out data port;
	networkaccess: requires bus access Network;
	powersource: in feature ;
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		error propagations
			sensedData: out propagation {ServiceOmission};
			powersource: in propagation {ServiceOmission};
			networkaccess: in propagation {ServiceOmission};
		flows
			-- in this abstraction we have the error source as contributor and the incoming power propagation.
			src1: error source sensedData{ServiceOmission} when {SensorFailure};
			src2: error path networkaccess{ServiceOmission} -> sensedData{ServiceOmission};
			path1: error path powersource{ServiceOmission} -> sensedData{ServiceOmission};
		end propagations;
		properties
			emv2::OccurrenceDistribution => [ ProbabilityValue => 2.5e-5 ; Distribution => Poisson;] applies to src1.ServiceOmission;
			emv2::OccurrenceDistribution => [ ProbabilityValue => 3.5e-5 ; Distribution => Poisson;] applies to networkaccess.ServiceOmission;
			emv2::OccurrenceDistribution => [ ProbabilityValue => 4.5e-5 ; Distribution => Poisson;] applies to powersource.ServiceOmission;
	**};
	end sensor;
	
Device sensor_errorbehavior extends sensor
-- we add component error behavior. In this case we introduce failure modes.
	annex EMV2 {**
--		use types ErrorLibrary, GPSErrorLibrary;
		use behavior ErrorLibrary::FailStop;
		component error behavior
		events
		-- we override Failure to associate an error type with the event
		 Failure: error event {SensorFailure};
		 -- transition elaborates error path path1 into an effect on the error state FailStop.
		 -- FailStop is propagated as specified by outprop. Its contributors are the Failure event and the incoming power failure.
		transitions
			powerfail: Operational -[powersource{ServiceOmission}]-> FailStop;
		propagations
			outprop1: FailStop -[]-> sensedData{ServiceOmission};
		end component;
	**};
	end sensor_errorbehavior;

-- for modeling availability by allowing recovery	
Device sensor_recovery extends sensor_errorbehavior
features
	reset: in event port; -- initiate reset recovery, which may fail to complete
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		use behavior ErrorLibrary::FailStop;
		component error behavior
		events
			ResetEvent: recover event when reset;
		transitions
			-- reset will be successful with 0.8 probability, and fail with 0.2 probability
			treset: FailStop -[ ResetEvent ]->
			    (Operational with 0.8, FailStop with 0.2);
		end component;
	**};
	end sensor_recovery;
	
	processor CPU
		features
			powersource: in feature;
			networkaccess: requires bus access Network;
	annex EMV2 {**
		use types ErrorLibrary,GPSErrorLibrary;
		error propagations
			bindings: out propagation {ServiceOmission};
			powersource: in propagation {ServiceOmission};
			networkaccess: out propagation {ServiceOmission};
			networkaccess: in propagation {ServiceOmission};
		flows
			cpu_es1: error source bindings {ServiceOmission} when {CPUFailure};
			-- network fails if processor fails since it is driven by processor
			cpu_es2: error source networkaccess {ServiceOmission} when {CPUFailure};
		end propagations;
	**};
	end CPU;
	
	processor CPU_errorbehavior extends CPU
	 annex EMV2 {**
		use types ErrorLibrary,GPSErrorLibrary;
	 	use behavior ErrorLibrary::FailStop;
	 	component error behavior
		events
		-- we override Failure to associate an error type with the event
		 Failure: error event {CPUFailure};
		propagations
		FailStop -[]-> bindings{ServiceOmission};
		FailStop -[]-> networkaccess{ServiceOmission};
	 	end component;
	 **};
	end CPU_errorbehavior;

	
	bus Network
		features
			power: in feature;
	annex EMV2 {**
		use types ErrorLibrary,GPSErrorLibrary;
		use behavior ErrorLibrary::FailStop;
		error propagations
		bindings: out propagation {ServiceOmission};
		power: in propagation {ServiceOmission};
		access: in propagation {ServiceOmission};
		access: out propagation {ServiceOmission};
		flows
			cpu_es: error path access{ServiceOmission} -> bindings {ServiceOmission} ;
			power_es: error path power{ServiceOmission} -> bindings {ServiceOmission} ;
			own_es: error source bindings {ServiceOmission} when {NetworkFailure};
		end propagations;
	**};
	end Network;
	
	device PowerSupply
	features
		power: out feature;
	annex EMV2 {**
		use types ErrorLibrary,GPSErrorLibrary;
		use behavior ErrorLibrary::FailStop;
		error propagations
			power: out propagation {ServiceOmission};
		flows
			cpu_es: error source power {ServiceOmission} when {PowerSupplyFailure};
		end propagations;
	 	component error behavior
		events
		-- we override Failure to associate an error type with the event
		 	Failure: error event {PowerSupplyFailure};
		propagations
			FailStop -[]-> power{ServiceOmission};
	 	end component;
		properties
			emv2::OccurrenceDistribution => [ ProbabilityValue => 2.5e-5 ; Distribution => Poisson;] applies to cpu_es.ServiceOmission;
			
	**};
	end PowerSupply;
	
	abstract GPSProcessing
	features
		inSensor1: in data port;
		inSensor2: in data port;
		location: out data port;
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		error propagations
		inSensor1 : in propagation {ServiceOmission};
		inSensor2 : in propagation {ServiceOmission};
		location : out propagation {ServiceOmission, LowPrecisionData};
		processor: in propagation {ServiceOmission};
		flows
			s1toloc: error path inSensor1 -> location;
			s2toloc: error path inSensor2 -> location;
			ptoloc: error path processor -> location;
		end propagations;
	**};
	end GPSProcessing;
	
	abstract GPSProcessing_redundancy extends GPSProcessing
	-- specify sensor processing logic without an explicit error behavior state machine
	-- in this case we just deal with the effects of redundant inputs.
	annex EMV2 {**
		component error behavior
		propagations
			outcond: all-[inSensor1{ServiceOmission} and inSensor2{ServiceOmission}]-> location{ServiceOmission};
		end component;
	**};
	end GPSProcessing_redundancy;
	
	abstract GPSProcessing_errorbehavior extends GPSProcessing_redundancy
	-- specify sensor processing logic with an explicit error behavior state machine.
	-- We need this if we want to identify the FTA source as state.
	-- in this case we need to map both error events and incoming propagations into a state.
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		use behavior GPSErrorLibrary::FailStopState;
		component error behavior
		transitions
			input: Operational -[inSensor1{ServiceOmission} and inSensor2{ServiceOmission}]-> FailStop;
		propagations
			outcond: FailStop-[]-> location{ServiceOmission};
		end component;
	**};
	end GPSProcessing_errorbehavior;
	
	abstract GPSProcessing_computeError extends GPSProcessing_redundancy
	-- specify sensor processing logic with an explicit error behavior state machine.
	-- We need this if we want to identify the FTA source as state.
	-- in this case we need to map both error events and incoming propagations into a state.
	-- We use types on the Failed state to distinguish them.
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		use behavior GPSErrorLibrary::GPSFailed;
		component error behavior
		events
			computeError: error Event;
		transitions
			internal: Operational -[computeError]-> Failed{LowPrecisionData}; 
			input: Operational -[inSensor1{ServiceOmission} and inSensor2{ServiceOmission}]-> Failed{ServiceOmission};
		propagations
			outcond1: Failed{ServiceOmission}-[]-> location{ServiceOmission};
			outcond2: Failed{LowPrecisionData}-[]-> location{LowPrecisionData};
		end component;
	**};
	end GPSProcessing_computeError;
	
	abstract GPSVoter 
		features
			in1: in data port;
			in2: in data port;
			outp: out data port;
	annex EMV2 {**
		use types ErrorLibrary, GPSErrorLibrary;
		error propagations
		in1 : in propagation {ServiceOmission,LowPrecisionData};
		in2 : in propagation {ServiceOmission,LowPrecisionData};
		outp : out propagation {ServiceOmission,LowPrecisionData};
		processor: in propagation {ServiceOmission};
		flows
			s1toloc: error path in1 -> outp;
			s2toloc: error path in2 -> outp;
			ptoloc: error path processor -> outp;
		end propagations;
		component error behavior
		propagations
			outcond: all-[(in1{ServiceOmission} and in2{ServiceOmission}) or processor{ServiceOmission}]-> outp{ServiceOmission};
			outcondlow1: all-[in1{ServiceOmission} or in2{ServiceOmission} or
				in1{LowPrecisionData} or in2{LowPrecisionData}
			]-> outp{LowPrecisionData};
		end component;
	**};
	end GPSVoter;
	
end GPSParts;
