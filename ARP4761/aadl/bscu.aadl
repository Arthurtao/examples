package bscu

public

with common;
with Base_Types;
with error_library;
with EMV2;
with ARP4761;

-- This is the implementation of the BSCU of the system
-- The BSCU contains two subsystems.
-- Each BSCU subsystem has the following interfaces:
--    1. Power
--    2. Pedal
-- Then, each BSCU subsystem has the following subcomponents:
--    1. A Command function that produces data from the pedal values.
--    2. A monitor function that indicates if the values are valid
--       or not.
-- The main BSCU receives data and power and forwards it
-- to each subsystem.
-- Also, the BSCU contains a Select_Alternate output data
-- that indicates wheter we should use the first subsystem
-- (Select_Alternate == false) or if the second (backup)
-- subsystem would be used (Select_Alternate == true).



-- The command system if part of each bscu subsystem.
-- It produces data from the brake pedal value.
-- This component is an error sink for the error side
-- and may fail from power-related error
-- and service-related error (no pedal).
system command
features
	pwr   : requires bus access common::power.generic;
	brake : out data port common::command.brake;
	skid  : out data port common::command.skid;
	pedal : requires bus access common::pwm.generic;
end command;

system implementation command.i
annex EMV2 {**
	use types     error_library;
	use behavior  error_library::simple;
	
	error propagations
		pwr   : in propagation {NoPower};
		pedal : in propagation {NoService};
	flows
		nopwr : error sink pwr{NoPower};
		nopedal : error sink pedal{NoService};
	end propagations;
	
	component error behavior
	transitions
		t1 : Operational -[pwr{NoPower}]-> Failed;
		t2 : Operational -[pedal{NoService}]-> Failed;
	end component;
**};
end command.i;


--  The monitor component receive the values
--  (brake and skid values) from the command system
--  and check if the system is valid or not. We have
--  one monitor for each BSCU.
--  The monitor may fail if he has no power.
system monitor
features
	pwr   : requires bus access common::power.generic;
	brake : in data port common::command.brake;
	skid  : in data port common::command.skid;
	valid : out data port Base_Types::Boolean;
end monitor;

system implementation monitor.i
annex EMV2 {**
	use types     error_library;
	use behavior  error_library::simple;
	
	error propagations
		pwr   : in propagation {NoPower};
	flows
		nopwr : error sink pwr{NoPower};
	end propagations;
	
	component error behavior
	events
		InvalidReport : error event;
	transitions
		t1 : Operational -[pwr{NoPower}]-> Failed;
		t2 : Operational -[InvalidReport]-> Failed;
	end component;
	properties
		ARP4761::severity => Minor applies to InvalidReport;
		ARP4761::likelihood => Probable applies to InvalidReport;
		EMV2::hazard => 
			[	crossreference => "TBD";
				failure => "Invalid Report from BSCU Monitor";
				phase => "TBD";
				description => "Report from a Monitor that causes an invalid switch to the alternate mode";
				comment => "Minor Hazard";
			]
			applies to InvalidReport;
**};
end monitor.i;


system bscu_subsystem
features
	pwr   : requires bus access common::power.generic;
	pedal : requires bus access common::pwm.generic;
	valid : out data port Base_Types::Boolean; 
end bscu_subsystem;

system implementation bscu_subsystem.i
subcomponents
	mon   : system monitor.i;
	cmd   : system command.i; 
connections
	pedaltocmd : bus access pedal <-> cmd.pedal;
	brakecmd   : port cmd.brake -> mon.brake;
	skidcmd    : port cmd.skid -> mon.skid;
	isvalid    : port mon.valid -> valid;
	pwrmon     : bus access pwr <-> mon.pwr;
    pwrcmd     : bus access pwr <-> cmd.pwr;
annex EMV2 {**
	use behavior error_library::simple;
	composite error behavior
	states
		[mon.failed or cmd.failed]-> Failed;
		[mon.operational and cmd.operational]-> Operational;
	end composite;
	properties
		EMV2::hazard => 
		[	crossreference => "ARP4761 figure L4 page 215";
			failure => "Failure of the BSCU, either from the monitor, the command or both";
			phase => "all";
			description => "Failure of a BSCU";
			comment => "Would be critical if two subsystem (primary and redundant) are deffective";
		]
		applies to Failed;
		ARP4761::severity => Major applies to Failed;
		ARP4761::likelihood => Probable applies to Failed;
		EMV2::OccurrenceDistribution => [ ProbabilityValue => 3.3e-5 ; Distribution => Fixed;] applies to Failed;
**};
end bscu_subsystem.i;


--  The select alternate is a binary operator that produces
--  an output from two input. If the first input is true
--  the result is false. Otherwise, the result is true. 
system select_alternate
features
	input1 : in data port Base_Types::Boolean;
	input2 : in data port Base_Types::Boolean;
	result : out data port Base_Types::Boolean;
annex EMV2 {**
	use types error_library;
	use behavior error_library::simple;
	
	error propagations
		result : out propagation{ValueError};
	flows
		f1 : error source result{ValueError};
	end propagations;

--
--  We consider that the component may have an inconsistent
--  behavior and select the alternate source where there is
--  no reason for that. We capture that using a single
--  event called InternalError.
--	
	component error behavior
	events
		InternalError : error event;
	transitions
		t1 : Operational -[InternalError]-> Failed;
	propagations
		p1 : Failed -[]-> result(ValueError);
	end component;
	
	properties
		-- EMV2::OccurrenceDistribution => [ ProbabilityValue => 1.30e-5 ; Distribution => Fixed;] applies to InternalError;
		EMV2::OccurrenceDistribution => [ ProbabilityValue => 3.6e-6 ; Distribution => Poisson;] applies to InternalError;
	
		ARP4761::severity => Hazardous applies to InternalError;
		ARP4761::likelihood => ExtremelyImprobable applies to InternalError;
		EMV2::hazard => 
			[	crossreference => "ARP4761 figure L4 page 215";
				failure => "";
				phase => "all";
				description => "BSCU validity monitor incorrectly report a Failure causing switch to alternate";
				comment => "";
			]
			applies to InternalError;
**};
end select_alternate;


system bscu
features
	pwr1              : requires bus access common::power.generic;
	pwr2              : requires bus access common::power.generic;
	pedal1            : requires bus access common::pwm.generic;
	pedal2            : requires bus access common::pwm.generic;
	Select_Alternate  : out data port Base_Types::Boolean;
	cmd_nor           : out data port common::command.skid; 
	cmd_alt           : out data port common::command.skid; 
annex EMV2 {**
	use types error_library;
	
	
	error propagations
		pwr1   : in propagation {NoPower};
		pwr2   : in propagation {NoPower};
	end propagations;
**};
end bscu;


system implementation bscu.i
subcomponents
	sub1    : system bscu_subsystem.i;
	sub2    : system bscu_subsystem.i;
	select  : system select_alternate;

connections
	sub1pwr        : bus access pwr1 <-> sub1.pwr;
	sub2pwr        : bus access pwr2 <-> sub2.pwr;
	sub1pedal      : bus access pedal1 <-> sub1.pedal;
	sub2pedal      : bus access pedal2 <-> sub2.pedal;
	selectvalid1   : port sub1.valid -> select.input1;
	selectvalid2   : port sub2.valid -> select.input2;
	selectvalidout : port select.result -> Select_Alternate;
annex EMV2 {**
	use types error_library;
	use behavior error_library::bscu;
	
	
	component error behavior
	transitions
		nopower : Operational -[pwr1{NoPower} and pwr2{NoPower}]-> Failed;
	end component;
	
	composite error behavior
	states
		[sub1.Failed and sub2.Failed]-> Failed;
		[sub1.Failed and sub2.Operational]-> Alternate;
		[sub1.Operational and sub2.Operational and select.Failed]-> Alternate;
		[sub1.Operational and sub2.Operational and select.Operational]->Operational;
	end composite;
	
	properties
			EMV2::hazard => 
		[	crossreference => "TBD";
			failure => "No power line";
			phase => "TBD";
			description => "Permanent failure of power supply source";
			comment => "Would be critical if both power supplies are lost";
		]
		applies to pwr1, pwr2;
**};
end bscu.i;


end bscu;