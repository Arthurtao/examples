package bscu

public

with common;
with Base_Types;
with error_library;

-- This is the implementation of the BSCU of the system
-- The BSCU contains two subsystems.
-- Each BSCU subsystem has the following interfaces:
--    1. Power
--    2. Pedal
-- Then, each BSCU subsystem has the following subcomponents:
--    1. A Command function that produces data from the pedal values.
--    2. A monitor function that indicates if the values are valid
--       or not.
-- The main BSCU receives data and power and forwards it
-- to each subsystem.
-- Also, the BSCU contains a Select_Alternate output data
-- that indicates wheter we should use the first subsystem
-- (Select_Alternate == false) or if the second (backup)
-- subsystem would be used (Select_Alternate == true).



-- The command system if part of each bscu subsystem.
-- It produces data from the brake pedal value.
-- This component is an error sink for the error side
-- and may fail from power-related error
-- and service-related error (no pedal).
system command
features
	pwr   : requires bus access common::power.generic;
	brake : out data port common::command.brake;
	skid  : out data port common::command.skid;
	pedal : requires bus access common::pwm.generic;
end command;

system implementation command.i
annex EMV2 {**
	use types     error_library;
	use behavior  error_library::simple;
	
	error propagations
		pwr   : in propagation {NoPower};
		pedal : in propagation {NoService};
	flows
		nopwr : error sink pwr{NoPower};
		nopedal : error sink pedal{NoService};
	end propagations;
	
	component error behavior
	transitions
		t1 : Operational -[pwr{NoPower}]-> Failed;
		t2 : Operational -[pedal{NoService}]-> Failed;
	end component;
**};
end command.i;


--  The monitor component receive the values
--  (brake and skid values) from the command system
--  and check if the system is valid or not. We have
--  one monitor for each BSCU.
--  The monitor may fail if he has no power.
system monitor
features
	pwr   : requires bus access common::power.generic;
	brake : in data port common::command.brake;
	skid  : in data port common::command.skid;
	valid : out data port Base_Types::Boolean;
end monitor;

system implementation monitor.i
annex EMV2 {**
	use types     error_library;
	use behavior  error_library::simple;
	
	error propagations
		pwr   : in propagation {NoPower};
	flows
		nopwr : error sink pwr{NoPower};
	end propagations;
	
	component error behavior
	transitions
		t1 : Operational -[pwr{NoPower}]-> Failed;
	end component;
**};
end monitor.i;


system bscu_subsystem
features
	pwr   : requires bus access common::power.generic;
	pedal : requires bus access common::pwm.generic;
	valid : out data port Base_Types::Boolean; 
end bscu_subsystem;

system implementation bscu_subsystem.i
subcomponents
	mon   : system monitor.i;
	cmd   : system command.i; 
connections
	pedaltocmd : bus access pedal <-> cmd.pedal;
	brakecmd   : port cmd.brake -> mon.brake;
	skidcmd    : port cmd.skid -> mon.skid;
	isvalid    : port mon.valid -> valid;
	pwrmon     : bus access pwr <-> mon.pwr;
    pwrcmd     : bus access pwr <-> cmd.pwr;
annex EMV2 {**
	use behavior error_library::simple;
	composite error behavior
	states
		[mon.failed or cmd.failed]-> Failed;
		[mon.operational and cmd.operational]-> Operational;
	end composite;
**};
end bscu_subsystem.i;


--  The select alternate is a binary operator that produces
--  an output from two input. If the first input is true
--  the result is false. Otherwise, the result is true. 
system select_alternate
features
	input1 : in data port Base_Types::Boolean;
	input2 : in data port Base_Types::Boolean;
	result : out data port Base_Types::Boolean;
end select_alternate;


system bscu
features
	pwr1              : requires bus access common::power.generic;
	pwr2              : requires bus access common::power.generic;
	pedal1            : requires bus access common::pwm.generic;
	pedal2            : requires bus access common::pwm.generic;
	Select_Alternate  : out data port Base_Types::Boolean;
	cmd_nor           : out data port common::command.skid; 
	cmd_alt           : out data port common::command.skid; 
annex EMV2 {**
	use types error_library;
	
	error propagations
		pwr1   : in propagation {NoPower};
		pwr2   : in propagation {NoPower};
		pedal1 : in propagation {NoService};
		pedal2 : in propagation {NoService};
	end propagations;
**};
end bscu;


system implementation bscu.i
subcomponents
	sub1    : system bscu_subsystem.i;
	sub2    : system bscu_subsystem.i;
	select  : system select_alternate;

connections
	sub1pwr        : bus access pwr1 <-> sub1.pwr;
	sub2pwr        : bus access pwr2 <-> sub2.pwr;
	sub1pedal      : bus access pedal1 <-> sub1.pedal;
	sub2pedal      : bus access pedal2 <-> sub2.pedal;
	selectvalid1   : port sub1.valid -> select.input1;
	selectvalid2   : port sub2.valid -> select.input2;
	selectvalidout : port select.result -> Select_Alternate;
end bscu.i;


end bscu;